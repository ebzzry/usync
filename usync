#! /usr/local/bin/scsh \
-e main -o table -s
!#

(define debug #f)

(define (butlast x)
  (reverse (cdr (reverse x))))

(define (string-split str . rest)
  (define (inc n)
    (+ n 1))

  ;; maxsplit is a positive number
  (define (split-by-whitespace str maxsplit)
    (define (skip-ws i yet-to-split-count)
      (cond
       ((>= i (string-length str)) '())
       ((char-whitespace? (string-ref str i))
        (skip-ws (inc i) yet-to-split-count))
       (else (scan-beg-word (inc i) i yet-to-split-count))))
    (define (scan-beg-word i from yet-to-split-count)
      (cond
       ((zero? yet-to-split-count)
        (cons (substring str from (string-length str)) '()))
       (else (scan-word i from yet-to-split-count))))
    (define (scan-word i from yet-to-split-count)
      (cond
       ((>= i (string-length str))
        (cons (substring str from i) '()))
       ((char-whitespace? (string-ref str i))
        (cons (substring str from i)
              (skip-ws (inc i) (- yet-to-split-count 1))))
       (else (scan-word (inc i) from yet-to-split-count))))
    (skip-ws 0 (- maxsplit 1)))

  ;; maxsplit is a positive number
  ;; str is not empty
  (define (split-by-charset str delimeters maxsplit)
    (define (scan-beg-word from yet-to-split-count)
      (cond
       ((>= from (string-length str)) '(""))
       ((zero? yet-to-split-count)
        (cons (substring str from (string-length str)) '()))
       (else (scan-word from from yet-to-split-count))))
    (define (scan-word i from yet-to-split-count)
      (cond
       ((>= i (string-length str))
        (cons (substring str from i) '()))
       ((memq (string-ref str i) delimeters)
        (cons (substring str from i)
              (scan-beg-word (inc i) (- yet-to-split-count 1))))
       (else (scan-word (inc i) from yet-to-split-count))))
    (scan-beg-word 0 (- maxsplit 1)))

  ;; resolver of overloading...
  ;; if omitted, maxsplit defaults to
  ;; (inc (string-length str))
  (if (string-null? str) '()
      (if (null? rest)
          (split-by-whitespace str (inc (string-length str)))
          (let ((charset (car rest))
                (maxsplit
                 (if (pair? (cdr rest)) (cadr rest) (inc (string-length str)))))
            (cond
             ((not (positive? maxsplit)) '())
             ((null? charset) (split-by-whitespace str maxsplit))
             (else (split-by-charset str charset maxsplit)))))))

;; doublequote items in a list
;; (quote-list '(foo bar baz) => '("foo" "bar" "baz")
(define (quote-list list)
  (map (lambda (item)
         (string-append
          (cond ((number? item) (number->string item))
                ((symbol? item) (symbol->string item))
                ((string? item) item))
          ""))
       list))

;; join strings in a list
;; (strings-join '("foo" "bar" "baz") => "foobarbaz"
(define (strings-join list)
  (cond ((null? list) "")
        (else (string-append
               (car list)
               (if (null? (cdr list))
                   "" " ")
               (strings-join (cdr list))))))

;; split a string using comma as a delimiter
(define (string-split/comma s)
  (string-split s '(#\,)))

;; outputs input -- for debugging use
(define (fake-run x) (format #t "~A~%" x))

;; print command to execute then execute command
(define (print-run command . quiet)
  (let ((form (strings-join (quote-list command))))
    (if (opt-ref 'fake-run)
        (fake-run form)
        (run (,@command)))))

;; flatten a list
(define (flatten x)
  (cond ((null? x) '())
        ((not (pair? x)) (list x))
        (else (append (flatten (car x))
                      (flatten (cdr x))))))
;; main

(define (display-usage)
  (let ((self (file-name-nondirectory (car (opt-ref 'arguments)))))
    (format #t
            "Usage: ~A [OPTION...] FILE... HOST[,HOST...]

Arguments:
  FILE                          file or directory
  HOST                          CSV list of hosts

Options:
  -h,  --help                   show this help
  -l,  --log                    record actions in --logfile option
       --logfile FILE           specify log file name
  -s,  --silent                 print nothing, except error messages
  -m,  --manual                 enable manual mode
  -n,  --dry-run                simulate command execution.
       --oneway                 use one-way synchronization using rsync 
       --twoway                 use two-way synchronization using unison (default)
  -e,  --protocol PROTOCOL      specify the transfer protocol to use
       --prefer ROOT            specify root to prefer
       --prefer-local           prefer local version of tree
       --prefer-remote          prefer remote version of tree
       --ignore PATHSPEC        specify ignore pathspec
       --ignore-regex REGEX     specify a regex ignore pathspec
       --ignore-name NAME       specify a name ignore pathspec
       --ignore-path PATH       specify a path ignore pathspec
       --noignore               do not ignore any file
       --brainwash HOSTS        delete metadata stored on HOSTS
" self)))

;; print the help summary then exit with exit-code
(define (display-usage-exit exit-code)
  (display-usage)
  (exit exit-code))

;; create hash tables and helpers
(define opt-table (make-table))
(define (opt-set! key value)
  (table-set! opt-table key value))
(define (opt-ref key)
  (table-ref opt-table key))
(define ignore-table (make-table))
(define (ignore-set! key value)
  (table-set! ignore-table key value))
(define (ignore-ref key)
  (table-ref ignore-table key))

;; initialize option table
(define (init-opt-table)
  (let ((table
         `((print-run . #f)
           (arguments . '())
           (program-name . #f)
           (hosts . #f)
           (brainwash . #f)
           (log . #f)
           (logfile . #f)
           (threads . "0")
           (date . ,(format-date "~Y~m~d~H~M" (date)))
           (help . #f)
           (verbose . #f)
           (silent . #f)
           (protocol . "rsh")
           (manual . #f)
           (prefer . #f)
           (prefer-local . #f)
           (prefer-remote . #f)
           (prefer-mode . #f)
           (oneway . #f)
           (noignore . #f)
           (fake-run . #f))))
    (do ((x table (cdr x)))
        ((null? x) x)
      (opt-set! (caar x) (cdar x)))))

(define (init-ignore-table)
  (let ((table
         `((primary . ())
           (secondary . ())
           (regex
            . (".*(cache|Cache|te?mp|history|thumbnails).*"
               ".*.[mM][pP]."
               ".*.[aA][vV][iI]" ".*.[wW][eE][bB][mM]"
               ".*.[eE][xX][eE]" ".*.[iI][sS][oO]"
               ".*.[fF][lL][vV]" ".*.[fF][lL][aA][cC]"
               ".*.[mM][kK][vV]"))
           (name
            . ("unison.log" ".ICEauthority" ".Xauthority"
               "*.core" ".serverauth*" ".thunderbird" ".mozilla"
               ".linux-opera" ".opera" ".macromedia" ".adobe"
               ".gconf*" ".gnome*" ".kde*" ".gimp*" ".fox*"
               ".gtk*" ".gstreamer*"
               ".evolution" ".config" ".icewm" ".wine"
               ".openoffice*" "OpenOffice.org*" ".java"
               ".nautilus" "*.lock" ".xchat*" ".xfetrash"
               ".mcop*" ".DCOP*" ".emacs-backups" ".emacs-auto-save"
               ".dbus" ".gvfs" ".gegl*" ".font" ".local*"
               "*.nosync" "*__"))
           (path
            . (".unison" ".Trash" "Trash" ".nfs*" "socket-*"
               ".emacs.d/auto-save-list")))))
    (do ((x table (cdr x)))
        ((null? x) x)
      (ignore-set! (caar x) (cdar x)))))

;; qualify path for unison format
(define (host-qualify-sync-tree host tree)
  (string-append (opt-ref 'protocol) "://" host "/" tree))

;; qualify path for rsync format
(define (host-qualify-rsync-tree host tree)
  (string-append host ":" tree))

(define (path-qualify host tree type)
  (case type
    ((src from)
     (case (opt-ref 'prefer-mode)
       ((0 'local)
        tree)
       ((1 'remote)
        (host-qualify-rsync-tree host tree))))
    ((dest to)
     (case (opt-ref 'prefer-mode)
       ((0 'local)
        (let ((p (file-name-directory tree)))
          (host-qualify-rsync-tree host p)))
       ((1 'remote)
        (file-name-directory tree))))))

;; remove trailing slash in directories
(define (strip-slash path)
  (if (file-directory? path)
      (directory-as-file-name path)
      path))

;; default logfile
(define (build-logfile base)
  (string-append
   base
   "/" (file-name-nondirectory (opt-ref 'program-name)) ".log"))

;; build options for unison mode
(define (build-other-options-sync-tree tree dest)
  (list (if (not (opt-ref 'manual)) "-batch" #f)
        (and (opt-ref 'log) "-log")
        (and (opt-ref 'log) (opt-ref 'logfile)
             `("-logfile" ,(opt-ref 'logfile)))
        (and (opt-ref 'silent) "-silent")
        (and (opt-ref 'prefer) `("-prefer" ,(opt-ref 'prefer)))
        (and (opt-ref 'prefer-local) `("-prefer" ,tree))
        (and (opt-ref 'prefer-remote) `("-prefer" ,dest))
        (and (opt-ref 'verbose) `("-debug" "verbose"))))

;; creates a pair for parse-args use for --ignore-* options
(define (ignore-insert type key args)
  (cons (string-append (ignore->string type)
                       (cadr args))
        (ignore-ref key)))

;; Map ignore type to correspinding -ignore string
(define (ignore->string type)
  (case type
    ((regex) "Regex ")
    ((name) "Name ")
    ((path) "Path ")))

;; build ignores (built-in rules)
(define (build-ignore-options-builtin type)
  (let p ((lst (ignore-ref type))
          (acc '()))
    (cond ((null? lst) acc)
          (else
           (p (cdr lst)
              (cons (list "-ignore"
                          (string-append (ignore->string type)
                                         (car lst)))
                    acc))))))

;; build ignore options (command line)
(define (build-ignore-options-user key)
  (let ((ignore (ignore-ref key)))
    (if (> (length ignore) 0)
        (map (lambda (x) (list "-ignore" x))
             (reverse ignore))
        '())))

;; remove empty options
(define (sanitize options)
  (remove (lambda (i) (not i)) options))

;; synchronize path with host
(define (sync-tree src dest)
  (let* ((default-options
           '("-rsync"
             "-fastcheck" "default"
             "-owner"
             "-group"
             "-times"
             "-ignorelocks"
             "-contactquietly"))
         (other-options
          (sanitize (flatten (build-other-options-sync-tree src dest))))
         (ignore-options
          (flatten (append
                    (build-ignore-options-builtin 'regex)
                    (build-ignore-options-builtin 'name)
                    (build-ignore-options-builtin 'path)
                    (build-ignore-options-user 'primary)
                    (build-ignore-options-user 'secondary)))))
    (print-run `(unison ,@(append default-options
                                  other-options
                                  (if (opt-ref 'noignore)
                                      '()
                                      ignore-options))
                        ,src ,dest))))

;; synchonize src to dest using rsync with delete
;; rsyncmode: specify correct src and dest here
(define (rsync-tree src dest)
  (let* ((default-options
           `("--archive" "--verbose" "--compress"
             "--delete" "-e" ,(opt-ref 'protocol)))
         (from (list (path-qualify dest src 'src)))
         (to (list (path-qualify dest src 'dest))))
    (print-run `(rsync ,@(append default-options from to)))))

;; synchronize tree with hosts
;; rsyncmode: specify correct src and dest here
(define (sync-hosts src dest)
  (let ((path (strip-slash (absolute-file-name src))))
    (for-each (lambda (dst)
                (if (opt-ref 'oneway)
                    (if (opt-ref 'prefer-mode)
                        (rsync-tree path dst)
                        (display-usage-exit 1))
                    (sync-tree path (host-qualify-sync-tree dst path))))
              dest)))

;; delete archive files on hosts
(define (brainwash hosts)
  (for-each (lambda (host)
              (print-run `(,(opt-ref 'protocol)
                           ,host "sudo rm -rf /root/.unison/ar*")))
            hosts)
  (exit 0))

;; primary argument parser
(define (parse-args args)
  (cond ((null? args) args)
        (else (case (string->symbol (car args))
                ((-h --help)
                 (display-usage-exit 0))
                ((-l --log)
                 (opt-set! 'log #t)
                 (parse-args (cdr args)))
                ((--logfile)
                 (opt-set! 'logfile (cadr args))
                 (parse-args (cddr args)))
                ((-s --silent)
                 (opt-set! 'silent #t)
                 (parse-args (cdr args)))
                ((-m --manual)
                 (opt-set! 'manual #t)
                 (parse-args (cdr args)))
                ((-n --dry-run --fake-run --expand)
                 (opt-set! 'fake-run #t)
                 (parse-args (cdr args)))
                ((-o -1 --oneway --one-way --rsync)
                 (opt-set! 'oneway #t)
                 (parse-args (cdr args)))
                ((--twoway --two-way)
                 (opt-set! 'oneway #f)
                 (parse-args (cdr args)))
                ((-e --protocol)
                 (opt-set! 'protocol (cadr args))
                 (parse-args (cddr args)))
                ((-t --threads)
                 (opt-set! 'threads (cadr args))
                 (parse-args (cddr args)))
                ((--prefer)
                 (opt-set! 'prefer (cadr args))
                 (parse-args (cddr args)))
                ((-pl --prefer-local)
                 (opt-set! 'prefer-local #t)
                 (opt-set! 'prefer-mode 0)
                 (parse-args (cdr args)))
                ((-pr --prefer-remote)
                 (opt-set! 'prefer-remote #t)
                 (opt-set! 'prefer-mode 1)
                 (parse-args (cdr args)))
                ((--noignore)
                 (opt-set! 'noignore #t)
                 (parse-args (cdr args)))
                ((--ignore)
                 (ignore-set! 'primary
                              (cons (cadr args)
                                    (ignore-ref 'primary)))
                 (parse-args (cddr args)))
                ((-ir --ignore-regexp --ignore-regex --ignore-re)
                 (ignore-set! 'secondary
                              (ignore-insert 'regex 'secondary args))
                 (parse-args (cddr args)))
                ((-in --ignore-name)
                 (ignore-set! 'secondary
                              (ignore-insert 'name 'secondary args))
                 (parse-args (cddr args)))
                ((-ip --ignore-path)
                 (ignore-set! 'secondary
                              (ignore-insert 'path 'secondary args))
                 (parse-args (cddr args)))
                ((--brainwash)
                 (opt-set! 'brainwash (string-split/comma (cadr args)))
                 (parse-args (cddr args)))
                ((-v --verbose)
                 (opt-set! 'verbose #t)
                 (parse-args (cdr args)))
                ((-D --debug)
                 (opt-set! 'print-run #t)
                 (parse-args (cdr args)))
                (else (let ((butlst (butlast args)))
                        (opt-set! 'hosts (string-split/comma (last args)))
                        butlst))))))

;; initialize hash tables
(define (init-tables)
  (init-opt-table))

;; internal
(define (%main args)
  (let ((tree (parse-args (cdr args))))
    (cond
     ((opt-ref 'brainwash)
      (brainwash (opt-ref 'brainwash)))
     ((or (not (opt-ref 'hosts)) (null? tree))
      (display-usage-exit 0))
     (else
      (for-each (lambda (file)
                  (if (file-exists? file)
                      (sync-hosts file (opt-ref 'hosts))
                      (display-usage-exit 1)))
                tree)))))

;; entry point
(define (main args)
  (init-tables)
  (opt-set! 'arguments args)
  (if (>= (length args) 3)
      (begin
        (opt-set! 'program-name (car args))
        (opt-set! 'logfile (build-logfile "/root"))
        (%main args))
      (begin
        (display-usage-exit 0))))

